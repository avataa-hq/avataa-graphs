from unittest.mock import Mock

import pytest


def get_node_key_by_id(arango_client, mo_id: int) -> str:
    """
    This method gets key by mo_id from database, where tmo_id = 42588
    """
    tmo_id_42588_db = arango_client.db(
        name="tmoId_42588", username="root", password=""
    )
    query = f"""
        FOR doc IN main
            FILTER doc.data.id == {mo_id}
            RETURN doc._key
    """
    data = tmo_id_42588_db.aql.execute(query=query)
    node_key = str([i for i in data][0])
    return node_key


def remove_keys_from_response(data: dict, key_to_delete: str, attrs: list[str]):
    """
    Arango has a specific function -- it randomly generates "ids" that are called "keys".
    Because we generate new objects with each test -- new keys are generated, and it is hard
    to keep track of the accuracy of the result,
    so this method removes the key or other (source/target) fields that are generated by Arango,
    and checks if that value is in the result at all.
    """
    for edge in data[key_to_delete]:
        for attr in attrs:
            assert attr in edge
            del edge[attr]
    return data


@pytest.fixture(scope="function")
def create_default_graph(client):
    req = {"tmo_id": 42588, "name": "first_graph"}
    res = client.post(url="/api/graph/v1/initialisation/", json=req)
    assert res.status_code == 202


@pytest.fixture(scope="function")
def build_default_graph(client):
    # get graph key. it generates randomly
    graphs = client.get(url="/api/graph/v1/initialisation/")
    graph_key = graphs.json()[0]["key"]

    # by default, it equals 'New'
    graph_status = graphs.json()[0]["status"]
    assert graph_status == "New"

    # SECOND.update graph,
    # by adding "start_from_tmo_id" attribute
    req = {"start_from_tmo_id": 42589, "trace_tmo_id": 42622}
    res = client.patch(url=f"/api/graph/v1/tmo/{graph_key}", json=req)
    assert res.status_code == 200

    # THIRD.build graph
    # because we create Process(task) -- we need mock endpoint, which creates process by instantly
    # run code, which build graph. without creating process
    from services.instances import run_building_in_new_process

    def new_build_graph_in_new_process(key):
        run_building_in_new_process(key=key)

    # it doesn't use, but we change it in memory by Mock
    build_graph_in_new_process = Mock(  # noqa
        side_effect=new_build_graph_in_new_process(graph_key)
    )

    res = client.post(url="/api/graph/v1/building/", params={"key": graph_key})

    assert res.status_code == 202

    # we need check if status of graph after building changed from 'New' to "Complete"
    graphs = client.get(url="/api/graph/v1/initialisation/")

    # after building, it must be changed to 'Complete'
    graph_status = graphs.json()[0]["status"]
    assert graph_status == "Complete"


@pytest.mark.skip(reason="Not implemented")
def test_trace_path_all(
    client, arango_client, create_default_graph, build_default_graph
):
    """
    POST /api/graph/v1/trace/path/all/{key}
    """
    graphs = client.get(url="/api/graph/v1/initialisation/")
    graph_key = graphs.json()[0]["key"]

    request_for_get_trace_path = {
        "node_key": get_node_key_by_id(
            arango_client=arango_client, mo_id=10817849
        )
    }

    response_trace_path = client.post(
        url=f"/api/graph/v1/trace/path/all/{graph_key}",
        json=request_for_get_trace_path,
    )
    assert response_trace_path.status_code == 200

    expected_response = [
        {
            "key": "450",
            "grouped_by_tprm": None,
            "name": "4G-123",
            "breadcrumbs": "/",
            "tmo": 42622,
            "mo_ids": [10818360],
            "label": None,
            "data": {
                "tmo_id": 42622,
                "p_id": None,
                "id": 10818360,
                "name": "4G-123",
                "label": None,
                "active": True,
                "version": 1,
                "latitude": None,
                "longitude": None,
                "pov": None,
                "geometry": None,
                "model": None,
                "point_a_id": None,
                "point_b_id": None,
                "status": None,
                "params": [
                    {
                        "tprm_id": 125951,
                        "mo_id": 10818360,
                        "value": "4G-123",
                        "id": 310619813,
                        "version": 1,
                    }
                ],
            },
            "connected_with": None,
        }
    ]

    #  Arango has a specific function -- it randomly generates "ids" that are called "keys".
    #  Because we generate new objects with each test -- new keys are generated, and it is hard
    #  to keep track of the accuracy of the result,
    #  so here we remove the key fields that are generated by Arango,
    #  and checks if that value is in the result at all.
    response_trace_path = response_trace_path.json()
    del expected_response[0]["key"]
    del response_trace_path[0]["key"]

    assert response_trace_path == expected_response


@pytest.mark.skip(reason="Not implemented")
def test_error_trace_path_all_node_dont_in_db(
    client, arango_client, create_default_graph, build_default_graph
):
    """
    PATCH /api/graph/v1/trace/path/all/{key}
    """
    graphs = client.get(url="/api/graph/v1/initialisation/")
    graph_key = graphs.json()[0]["key"]

    req = {"node_key": "0000"}

    res = client.post(url=f"/api/graph/v1/trace/path/all/{graph_key}", json=req)
    assert res.status_code == 404
    assert res.json() == {"detail": "Nodes not found in database"}


@pytest.mark.skip(reason="Not implemented")
def test_trace_nodes_by_mo_id(
    client, arango_client, create_default_graph, build_default_graph
):
    """
    POST /api/graph/v1/trace/nodes_by_mo_id/{key}
    """

    response_from_getting_nodes_by_mo_id = client.post(
        url=f"/api/graph/v1/trace/nodes_by_mo_id/{10818360}"
    )
    assert response_from_getting_nodes_by_mo_id.status_code == 200

    expected_response = [
        {
            "name": "first_graph",
            "nodes": [
                {
                    "grouped_by_tprm": None,
                    "name": "4G-123",
                    "breadcrumbs": "/",
                    "tmo": 42622,
                    "mo_ids": [10818360],
                    "label": None,
                    "data": {
                        "tmo_id": 42622,
                        "p_id": None,
                        "id": 10818360,
                        "name": "4G-123",
                        "active": True,
                        "version": 1,
                        "latitude": None,
                        "longitude": None,
                        "pov": None,
                        "geometry": None,
                        "model": None,
                        "point_a_id": None,
                        "point_b_id": None,
                        "status": None,
                        "label": None,
                        "params": [
                            {
                                "tprm_id": 125951,
                                "mo_id": 10818360,
                                "value": "4G-123",
                                "id": 310619813,
                                "version": 1,
                            }
                        ],
                    },
                    "connected_with": None,
                }
            ],
        }
    ]
    response_from_getting_nodes_by_mo_id = (
        response_from_getting_nodes_by_mo_id.json()
    )

    #  Arango has a specific function -- it randomly generates "ids" that are called "keys".
    #  Because we generate new objects with each test -- new keys are generated, and it is hard
    #  to keep track of the accuracy of the result,
    #  so here we remove the key fields that are generated by Arango,
    #  and checks if that value is in the result at all.
    del response_from_getting_nodes_by_mo_id[0]["key"]
    del response_from_getting_nodes_by_mo_id[0]["nodes"][0]["key"]

    assert response_from_getting_nodes_by_mo_id == expected_response


# TODO: need to update this test
# it raise Arango service error, reason of what, we can't determine
# def test_trace_path_between_nodes(client, arango_client, create_default_graph, build_default_graph):
#     """
#         POST /api/graph/v1/trace/path_between_nodes/{key}
#     """
#     graphs = client.get(url='/api/graph/v1/initialisation/')
#     graph_key = graphs.json()[0]['key']
#
#     node_key_a = get_node_key_by_id(arango_client=arango_client, mo_id=10817854)
#     node_key_b = get_node_key_by_id(arango_client=arango_client, mo_id=10817849)
#
#     res = client.post(url=f'/api/graph/v1/trace/path_between_nodes/{graph_key}', params={'node_key_a': node_key_a,
#                                                                                          'node_key_b': node_key_b})
#     assert res.status_code == 200

from unittest.mock import Mock

import pytest


def remove_keys_from_response(data: dict, key_to_delete: str, attrs: list[str]):
    """
    Arango has a specific function -- it randomly generates "ids" that are called "keys".
    Because we generate new objects with each test -- new keys are generated, and it is hard
    to keep track of the accuracy of the result,
    so this method removes the key or other (source/target) fields that are generated by Arango,
    and checks if that value is in the result at all.
    """
    for edge in data[key_to_delete]:
        for attr in attrs:
            assert attr in edge
            del edge[attr]
    return data


def get_node_key_by_id(arango_client, mo_id: int) -> str:
    """
    This method gets key by mo_id from database, where tmo_id = 42588
    """
    tmo_id_42588_db = arango_client.db(
        name="tmoId_42588", username="root", password=""
    )
    query = f"""
        FOR doc IN main
            FILTER doc.data.id == {mo_id}
            RETURN doc._key
    """
    data = tmo_id_42588_db.aql.execute(query=query)
    node_key = str([i for i in data][0])
    return node_key


@pytest.fixture(scope="function")
def create_default_graph(client):
    req = {"tmo_id": 42588, "name": "first_graph"}
    res = client.post(url="/api/graph/v1/initialisation/", json=req)
    assert res.status_code == 202


@pytest.fixture(scope="function")
def build_default_graph(client):
    # get graph key. it generates randomly
    graphs = client.get(url="/api/graph/v1/initialisation/")
    graph_key = graphs.json()[0]["key"]

    # by default, it equals 'New'
    graph_status = graphs.json()[0]["status"]
    assert graph_status == "New"

    # SECOND.update graph,
    # by adding "start_from_tmo_id" attribute and add "trace_tmo_id"
    req = {"start_from_tmo_id": 42589, "trace_tmo_id": 42589}
    res = client.patch(url=f"/api/graph/v1/tmo/{graph_key}", json=req)
    assert res.status_code == 200

    # THIRD.build graph
    # because we create Process(task) -- we need mock endpoint, which creates process by instantly
    # run code, which build graph. without creating process
    from services.instances import run_building_in_new_process

    def new_build_graph_in_new_process(key):
        run_building_in_new_process(key=key)

    # it doesn't use, but we change it in memory by Mock
    build_graph_in_new_process = Mock(  # noqa
        side_effect=new_build_graph_in_new_process(graph_key)
    )

    res = client.post(url="/api/graph/v1/building/", params={"key": graph_key})

    assert res.status_code == 202

    # we need check if status of graph after building changed from 'New' to "Complete"
    graphs = client.get(url="/api/graph/v1/initialisation/")

    # after building, it must be changed to 'Complete'
    graph_status = graphs.json()[0]["status"]
    assert graph_status == "Complete"


@pytest.mark.skip(reason="Not implemented")
def test_search_hierarchy(
    client, arango_client, create_default_graph, build_default_graph
):
    """
    GET /api/graph/search/hierarchy/{key}

        This endpoint get data from hierarchy by graph data
    """
    graphs = client.get(url="/api/graph/v1/initialisation/")
    graph_key = graphs.json()[0]["key"]

    request_to_search_hierarchy = {
        "node_key": get_node_key_by_id(
            arango_client=arango_client, mo_id=10817854
        )
    }

    response_from_server_getting_hierarchy = client.get(
        url=f"/api/graph/v1/search/hierarchy/{graph_key}",
        params=request_to_search_hierarchy,
    )
    assert response_from_server_getting_hierarchy.status_code == 200

    expected_response = [
        {
            "key": "341",
            "grouped_by_tprm": None,
            "breadcrumbs": "/",
            "name": "Location 2",
            "label": None,
            "tmo": 42589,
            "mo_ids": [10817849],
            "data": {
                "tmo_id": 42589,
                "p_id": None,
                "id": 10817849,
                "name": "Location 2",
                "label": None,
                "active": True,
                "version": 1,
                "latitude": 1.0,
                "longitude": 1.0,
                "pov": None,
                "geometry": None,
                "model": None,
                "point_a_id": None,
                "point_b_id": None,
                "status": None,
                "params": [
                    {
                        "tprm_id": 125897,
                        "mo_id": 10817849,
                        "value": 1,
                        "id": 310602568,
                        "version": 1,
                    },
                    {
                        "tprm_id": 125898,
                        "mo_id": 10817849,
                        "value": 1,
                        "id": 310602569,
                        "version": 1,
                    },
                    {
                        "tprm_id": 125943,
                        "mo_id": 10817849,
                        "value": "Location 2",
                        "id": 310602570,
                        "version": 1,
                    },
                ],
            },
            "connected_with": None,
        },
        {
            "key": "352",
            "grouped_by_tprm": None,
            "breadcrumbs": "/",
            "name": "Microwave 2",
            "label": None,
            "tmo": 42591,
            "mo_ids": [10817854],
            "data": {
                "tmo_id": 42591,
                "p_id": 10817849,
                "id": 10817854,
                "name": "Microwave 2",
                "label": None,
                "active": True,
                "version": 1,
                "latitude": None,
                "longitude": None,
                "pov": None,
                "geometry": None,
                "model": None,
                "point_a_id": None,
                "point_b_id": None,
                "status": None,
                "params": [
                    {
                        "tprm_id": 125912,
                        "mo_id": 10817854,
                        "value": "Microwave 2",
                        "id": 310602579,
                        "version": 1,
                    }
                ],
            },
            "connected_with": None,
        },
    ]

    # Arango has a specific function -- it randomly generates "ids" that are called "keys".
    # Because we generate new objects with each test -- new keys are generated, and it is hard
    # to keep track of the accuracy of the result,
    # so we need to delete key`s from results, but we check, that is inside request
    for node in expected_response:
        assert "key" in node
        del node["key"]
        del node["breadcrumbs"]

    response_from_server = response_from_server_getting_hierarchy.json()
    for node in response_from_server:
        assert "key" in node
        del node["key"]
        del node["breadcrumbs"]

    assert response_from_server == expected_response


@pytest.mark.skip(reason="Not implemented")
def test_search_by_value(
    client, arango_client, create_default_graph, build_default_graph
):
    """
    GET /api/graph/search/{key}

        This endpoint get data from hierarchy by graph data
    """
    graphs = client.get(url="/api/graph/v1/initialisation/")
    graph_key = graphs.json()[0]["key"]

    request_to_search_by_values = {"query": "Location 2"}

    response_from_server_get_data_by_value = client.get(
        url=f"/api/graph/v1/search/{graph_key}",
        params=request_to_search_by_values,
    )
    assert response_from_server_get_data_by_value.status_code == 200

    expected_response = {
        "nodes": [
            {
                "key": "731",
                "grouped_by_tprm": None,
                "breadcrumbs": "/",
                "name": "Location 2",
                "label": None,
                "tmo": 42589,
                "mo_ids": [10817849],
                "data": {
                    "tmo_id": 42589,
                    "p_id": None,
                    "id": 10817849,
                    "name": "Location 2",
                    "label": None,
                    "active": True,
                    "version": 1,
                    "latitude": 1,
                    "longitude": 1,
                    "pov": None,
                    "geometry": None,
                    "model": None,
                    "point_a_id": None,
                    "point_b_id": None,
                    "status": None,
                    "params": [
                        {
                            "tprm_id": 125897,
                            "mo_id": 10817849,
                            "value": 1,
                            "id": 310602568,
                            "version": 1,
                        },
                        {
                            "tprm_id": 125898,
                            "mo_id": 10817849,
                            "value": 1,
                            "id": 310602569,
                            "version": 1,
                        },
                        {
                            "tprm_id": 125943,
                            "mo_id": 10817849,
                            "value": "Location 2",
                            "id": 310602570,
                            "version": 1,
                        },
                    ],
                },
                "connected_with": None,
            }
        ],
        "tmo": [
            {
                "name": "Location Small",
                "geometry_type": None,
                "tmo_id": 42589,
                "icon": "LocationOn",
                "line_type": None,
            }
        ],
    }

    # remove keys from NODES(expected)
    expected_result = remove_keys_from_response(
        data=expected_response,
        key_to_delete="nodes",
        attrs=["key", "breadcrumbs"],
    )
    # remove keys from NODES(server)
    response_from_server_get_data_by_value = remove_keys_from_response(
        response_from_server_get_data_by_value.json(),
        key_to_delete="nodes",
        attrs=["key", "breadcrumbs"],
    )

    assert expected_result == response_from_server_get_data_by_value
